{"ast":null,"code":"import _objectSpread from \"/home/cameron/Desktop/AlbaSoftwareWebsite/articleswebsite/site/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n/**\n * @import {\n *   Code,\n *   Construct,\n *   Resolver,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownSpace } from 'micromark-util-character';\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  resolveTo: resolveToSetextUnderline,\n  tokenize: tokenizeSetextUnderline\n};\n\n/** @type {Resolver} */\nfunction resolveToSetextUnderline(events, context) {\n  // To do: resolve like `markdown-rs`.\n  let index = events.length;\n  /** @type {number | undefined} */\n  let content;\n  /** @type {number | undefined} */\n  let text;\n  /** @type {number | undefined} */\n  let definition;\n\n  // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === \"content\") {\n        content = index;\n        break;\n      }\n      if (events[index][1].type === \"paragraph\") {\n        text = index;\n      }\n    }\n    // Exit\n    else {\n      if (events[index][1].type === \"content\") {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1);\n      }\n      if (!definition && events[index][1].type === \"definition\") {\n        definition = index;\n      }\n    }\n  }\n  const heading = {\n    type: \"setextHeading\",\n    start: _objectSpread({}, events[text][1].start),\n    end: _objectSpread({}, events[events.length - 1][1].end)\n  };\n\n  // Change the paragraph to setext heading text.\n  events[text][1].type = \"setextHeadingText\";\n\n  // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context]);\n    events.splice(definition + 1, 0, ['exit', events[content][1], context]);\n    events[content][1].end = _objectSpread({}, events[definition][1].end);\n  } else {\n    events[content][1] = heading;\n  }\n\n  // Add the heading exit at the end.\n  events.push(['exit', heading, context]);\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this;\n  /** @type {NonNullable<Code>} */\n  let marker;\n  return start;\n\n  /**\n   * At start of heading (setext) underline.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length;\n    /** @type {boolean | undefined} */\n    let paragraph;\n    // Find an opening.\n    while (index--) {\n      // Skip enter/exit of line ending, line prefix, and content.\n      // We can now either have a definition or a paragraph.\n      if (self.events[index][1].type !== \"lineEnding\" && self.events[index][1].type !== \"linePrefix\" && self.events[index][1].type !== \"content\") {\n        paragraph = self.events[index][1].type === \"paragraph\";\n        break;\n      }\n    }\n\n    // To do: handle lazy/pierce like `markdown-rs`.\n    // To do: parse indent like `markdown-rs`.\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter(\"setextHeadingLine\");\n      marker = code;\n      return before(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * After optional whitespace, at `-` or `=`.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter(\"setextHeadingLineSequence\");\n    return inside(code);\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return inside;\n    }\n    effects.exit(\"setextHeadingLineSequence\");\n    return markdownSpace(code) ? factorySpace(effects, after, \"lineSuffix\")(code) : after(code);\n  }\n\n  /**\n   * After sequence, after optional whitespace.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"setextHeadingLine\");\n      return ok(code);\n    }\n    return nok(code);\n  }\n}","map":{"version":3,"names":["factorySpace","markdownLineEnding","markdownSpace","setextUnderline","name","resolveTo","resolveToSetextUnderline","tokenize","tokenizeSetextUnderline","events","context","index","length","content","text","definition","type","splice","heading","start","_objectSpread","end","push","effects","ok","nok","self","marker","code","paragraph","parser","lazy","now","line","interrupt","enter","before","inside","consume","exit","after"],"sources":["/home/cameron/Desktop/AlbaSoftwareWebsite/articleswebsite/site/node_modules/micromark-core-commonmark/lib/setext-underline.js"],"sourcesContent":["/**\n * @import {\n *   Code,\n *   Construct,\n *   Resolver,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownSpace } from 'micromark-util-character';\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  resolveTo: resolveToSetextUnderline,\n  tokenize: tokenizeSetextUnderline\n};\n\n/** @type {Resolver} */\nfunction resolveToSetextUnderline(events, context) {\n  // To do: resolve like `markdown-rs`.\n  let index = events.length;\n  /** @type {number | undefined} */\n  let content;\n  /** @type {number | undefined} */\n  let text;\n  /** @type {number | undefined} */\n  let definition;\n\n  // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === \"content\") {\n        content = index;\n        break;\n      }\n      if (events[index][1].type === \"paragraph\") {\n        text = index;\n      }\n    }\n    // Exit\n    else {\n      if (events[index][1].type === \"content\") {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1);\n      }\n      if (!definition && events[index][1].type === \"definition\") {\n        definition = index;\n      }\n    }\n  }\n  const heading = {\n    type: \"setextHeading\",\n    start: {\n      ...events[text][1].start\n    },\n    end: {\n      ...events[events.length - 1][1].end\n    }\n  };\n\n  // Change the paragraph to setext heading text.\n  events[text][1].type = \"setextHeadingText\";\n\n  // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context]);\n    events.splice(definition + 1, 0, ['exit', events[content][1], context]);\n    events[content][1].end = {\n      ...events[definition][1].end\n    };\n  } else {\n    events[content][1] = heading;\n  }\n\n  // Add the heading exit at the end.\n  events.push(['exit', heading, context]);\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this;\n  /** @type {NonNullable<Code>} */\n  let marker;\n  return start;\n\n  /**\n   * At start of heading (setext) underline.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length;\n    /** @type {boolean | undefined} */\n    let paragraph;\n    // Find an opening.\n    while (index--) {\n      // Skip enter/exit of line ending, line prefix, and content.\n      // We can now either have a definition or a paragraph.\n      if (self.events[index][1].type !== \"lineEnding\" && self.events[index][1].type !== \"linePrefix\" && self.events[index][1].type !== \"content\") {\n        paragraph = self.events[index][1].type === \"paragraph\";\n        break;\n      }\n    }\n\n    // To do: handle lazy/pierce like `markdown-rs`.\n    // To do: parse indent like `markdown-rs`.\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter(\"setextHeadingLine\");\n      marker = code;\n      return before(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * After optional whitespace, at `-` or `=`.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter(\"setextHeadingLineSequence\");\n    return inside(code);\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return inside;\n    }\n    effects.exit(\"setextHeadingLineSequence\");\n    return markdownSpace(code) ? factorySpace(effects, after, \"lineSuffix\")(code) : after(code);\n  }\n\n  /**\n   * After sequence, after optional whitespace.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"setextHeadingLine\");\n      return ok(code);\n    }\n    return nok(code);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}