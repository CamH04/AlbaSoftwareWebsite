{"ast":null,"code":"/**\n * @import {\n *   Code,\n *   Construct,\n *   Exiter,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { asciiDigit, markdownSpace } from 'micromark-util-character';\nimport { blankLine } from './blank-line.js';\nimport { thematicBreak } from './thematic-break.js';\n\n/** @type {Construct} */\nexport const list = {\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd,\n  name: 'list',\n  tokenize: tokenizeListStart\n};\n\n/** @type {Construct} */\nconst listItemPrefixWhitespaceConstruct = {\n  partial: true,\n  tokenize: tokenizeListItemPrefixWhitespace\n};\n\n/** @type {Construct} */\nconst indentConstruct = {\n  partial: true,\n  tokenize: tokenizeIndent\n};\n\n// To do: `markdown-rs` parses list items on their own and later stitches them\n// together.\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  let initialSize = tail && tail[1].type === \"linePrefix\" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let size = 0;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    const kind = self.containerState.type || (code === 42 || code === 43 || code === 45 ? \"listUnordered\" : \"listOrdered\");\n    if (kind === \"listUnordered\" ? !self.containerState.marker || code === self.containerState.marker : asciiDigit(code)) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind;\n        effects.enter(kind, {\n          _container: true\n        });\n      }\n      if (kind === \"listUnordered\") {\n        effects.enter(\"listItemPrefix\");\n        return code === 42 || code === 45 ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);\n      }\n      if (!self.interrupt || code === 49) {\n        effects.enter(\"listItemPrefix\");\n        effects.enter(\"listItemValue\");\n        return inside(code);\n      }\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code);\n      return inside;\n    }\n    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code === self.containerState.marker : code === 41 || code === 46)) {\n      effects.exit(\"listItemValue\");\n      return atMarker(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * @type {State}\n   **/\n  function atMarker(code) {\n    effects.enter(\"listItemMarker\");\n    effects.consume(code);\n    effects.exit(\"listItemMarker\");\n    self.containerState.marker = self.containerState.marker || code;\n    return effects.check(blankLine,\n    // Can’t be empty when interrupting.\n    self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));\n  }\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true;\n    initialSize++;\n    return endOfPrefix(code);\n  }\n\n  /** @type {State} */\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter(\"listItemPrefixWhitespace\");\n      effects.consume(code);\n      effects.exit(\"listItemPrefixWhitespace\");\n      return endOfPrefix;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function endOfPrefix(code) {\n    self.containerState.size = initialSize + self.sliceSerialize(effects.exit(\"listItemPrefix\"), true).length;\n    return ok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this;\n  self.containerState._closeFlow = undefined;\n  return effects.check(blankLine, onBlank, notBlank);\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;\n\n    // We have a blank line.\n    // Still, try to consume at most the items size.\n    return factorySpace(effects, ok, \"listItemIndent\", self.containerState.size + 1)(code);\n  }\n\n  /** @type {State} */\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined;\n      self.containerState.initialBlankLine = undefined;\n      return notInCurrentItem(code);\n    }\n    self.containerState.furtherBlankLines = undefined;\n    self.containerState.initialBlankLine = undefined;\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);\n  }\n\n  /** @type {State} */\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true;\n    // As we’re closing flow, we’re no longer interrupting.\n    self.interrupt = undefined;\n    // Always populated by defaults.\n\n    return factorySpace(effects, effects.attempt(list, ok, nok), \"linePrefix\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4)(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this;\n  return factorySpace(effects, afterPrefix, \"listItemIndent\", self.containerState.size + 1);\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === \"listItemIndent\" && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok(code) : nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Exiter}\n */\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type);\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this;\n\n  // Always populated by defaults.\n\n  return factorySpace(effects, afterPrefix, \"listItemPrefixWhitespace\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4 + 1);\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return !markdownSpace(code) && tail && tail[1].type === \"listItemPrefixWhitespace\" ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"names":["factorySpace","asciiDigit","markdownSpace","blankLine","thematicBreak","list","continuation","tokenize","tokenizeListContinuation","exit","tokenizeListEnd","name","tokenizeListStart","listItemPrefixWhitespaceConstruct","partial","tokenizeListItemPrefixWhitespace","indentConstruct","tokenizeIndent","effects","ok","nok","self","tail","events","length","initialSize","type","sliceSerialize","size","start","code","kind","containerState","marker","enter","_container","check","atMarker","interrupt","inside","consume","onBlank","attempt","endOfPrefix","otherPrefix","initialBlankLine","_closeFlow","undefined","notBlank","furtherBlankLines","notInCurrentItem","parser","constructs","disable","null","includes","afterPrefix"],"sources":["/home/cameron/Desktop/AlbaSoftwareWebsite/articleswebsite/site/node_modules/micromark-core-commonmark/lib/list.js"],"sourcesContent":["/**\n * @import {\n *   Code,\n *   Construct,\n *   Exiter,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { asciiDigit, markdownSpace } from 'micromark-util-character';\nimport { blankLine } from './blank-line.js';\nimport { thematicBreak } from './thematic-break.js';\n\n/** @type {Construct} */\nexport const list = {\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd,\n  name: 'list',\n  tokenize: tokenizeListStart\n};\n\n/** @type {Construct} */\nconst listItemPrefixWhitespaceConstruct = {\n  partial: true,\n  tokenize: tokenizeListItemPrefixWhitespace\n};\n\n/** @type {Construct} */\nconst indentConstruct = {\n  partial: true,\n  tokenize: tokenizeIndent\n};\n\n// To do: `markdown-rs` parses list items on their own and later stitches them\n// together.\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  let initialSize = tail && tail[1].type === \"linePrefix\" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let size = 0;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    const kind = self.containerState.type || (code === 42 || code === 43 || code === 45 ? \"listUnordered\" : \"listOrdered\");\n    if (kind === \"listUnordered\" ? !self.containerState.marker || code === self.containerState.marker : asciiDigit(code)) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind;\n        effects.enter(kind, {\n          _container: true\n        });\n      }\n      if (kind === \"listUnordered\") {\n        effects.enter(\"listItemPrefix\");\n        return code === 42 || code === 45 ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);\n      }\n      if (!self.interrupt || code === 49) {\n        effects.enter(\"listItemPrefix\");\n        effects.enter(\"listItemValue\");\n        return inside(code);\n      }\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code);\n      return inside;\n    }\n    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code === self.containerState.marker : code === 41 || code === 46)) {\n      effects.exit(\"listItemValue\");\n      return atMarker(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * @type {State}\n   **/\n  function atMarker(code) {\n    effects.enter(\"listItemMarker\");\n    effects.consume(code);\n    effects.exit(\"listItemMarker\");\n    self.containerState.marker = self.containerState.marker || code;\n    return effects.check(blankLine,\n    // Can’t be empty when interrupting.\n    self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));\n  }\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true;\n    initialSize++;\n    return endOfPrefix(code);\n  }\n\n  /** @type {State} */\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter(\"listItemPrefixWhitespace\");\n      effects.consume(code);\n      effects.exit(\"listItemPrefixWhitespace\");\n      return endOfPrefix;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function endOfPrefix(code) {\n    self.containerState.size = initialSize + self.sliceSerialize(effects.exit(\"listItemPrefix\"), true).length;\n    return ok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this;\n  self.containerState._closeFlow = undefined;\n  return effects.check(blankLine, onBlank, notBlank);\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;\n\n    // We have a blank line.\n    // Still, try to consume at most the items size.\n    return factorySpace(effects, ok, \"listItemIndent\", self.containerState.size + 1)(code);\n  }\n\n  /** @type {State} */\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined;\n      self.containerState.initialBlankLine = undefined;\n      return notInCurrentItem(code);\n    }\n    self.containerState.furtherBlankLines = undefined;\n    self.containerState.initialBlankLine = undefined;\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);\n  }\n\n  /** @type {State} */\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true;\n    // As we’re closing flow, we’re no longer interrupting.\n    self.interrupt = undefined;\n    // Always populated by defaults.\n\n    return factorySpace(effects, effects.attempt(list, ok, nok), \"linePrefix\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4)(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this;\n  return factorySpace(effects, afterPrefix, \"listItemIndent\", self.containerState.size + 1);\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === \"listItemIndent\" && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok(code) : nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Exiter}\n */\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type);\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this;\n\n  // Always populated by defaults.\n\n  return factorySpace(effects, afterPrefix, \"listItemPrefixWhitespace\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4 + 1);\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return !markdownSpace(code) && tail && tail[1].type === \"listItemPrefixWhitespace\" ? ok(code) : nok(code);\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,YAAY,QAAQ,yBAAyB;AACtD,SAASC,UAAU,EAAEC,aAAa,QAAQ,0BAA0B;AACpE,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,aAAa,QAAQ,qBAAqB;;AAEnD;AACA,OAAO,MAAMC,IAAI,GAAG;EAClBC,YAAY,EAAE;IACZC,QAAQ,EAAEC;EACZ,CAAC;EACDC,IAAI,EAAEC,eAAe;EACrBC,IAAI,EAAE,MAAM;EACZJ,QAAQ,EAAEK;AACZ,CAAC;;AAED;AACA,MAAMC,iCAAiC,GAAG;EACxCC,OAAO,EAAE,IAAI;EACbP,QAAQ,EAAEQ;AACZ,CAAC;;AAED;AACA,MAAMC,eAAe,GAAG;EACtBF,OAAO,EAAE,IAAI;EACbP,QAAQ,EAAEU;AACZ,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASL,iBAAiBA,CAACM,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EAC3C,MAAMC,IAAI,GAAG,IAAI;EACjB,MAAMC,IAAI,GAAGD,IAAI,CAACE,MAAM,CAACF,IAAI,CAACE,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC;EAChD,IAAIC,WAAW,GAAGH,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,CAACI,IAAI,KAAK,YAAY,GAAGJ,IAAI,CAAC,CAAC,CAAC,CAACK,cAAc,CAACL,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAACE,MAAM,GAAG,CAAC;EAC1G,IAAII,IAAI,GAAG,CAAC;EACZ,OAAOC,KAAK;;EAEZ;EACA,SAASA,KAAKA,CAACC,IAAI,EAAE;IACnB,MAAMC,IAAI,GAAGV,IAAI,CAACW,cAAc,CAACN,IAAI,KAAKI,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,EAAE,GAAG,eAAe,GAAG,aAAa,CAAC;IACtH,IAAIC,IAAI,KAAK,eAAe,GAAG,CAACV,IAAI,CAACW,cAAc,CAACC,MAAM,IAAIH,IAAI,KAAKT,IAAI,CAACW,cAAc,CAACC,MAAM,GAAGhC,UAAU,CAAC6B,IAAI,CAAC,EAAE;MACpH,IAAI,CAACT,IAAI,CAACW,cAAc,CAACN,IAAI,EAAE;QAC7BL,IAAI,CAACW,cAAc,CAACN,IAAI,GAAGK,IAAI;QAC/Bb,OAAO,CAACgB,KAAK,CAACH,IAAI,EAAE;UAClBI,UAAU,EAAE;QACd,CAAC,CAAC;MACJ;MACA,IAAIJ,IAAI,KAAK,eAAe,EAAE;QAC5Bb,OAAO,CAACgB,KAAK,CAAC,gBAAgB,CAAC;QAC/B,OAAOJ,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,EAAE,GAAGZ,OAAO,CAACkB,KAAK,CAAChC,aAAa,EAAEgB,GAAG,EAAEiB,QAAQ,CAAC,CAACP,IAAI,CAAC,GAAGO,QAAQ,CAACP,IAAI,CAAC;MACxG;MACA,IAAI,CAACT,IAAI,CAACiB,SAAS,IAAIR,IAAI,KAAK,EAAE,EAAE;QAClCZ,OAAO,CAACgB,KAAK,CAAC,gBAAgB,CAAC;QAC/BhB,OAAO,CAACgB,KAAK,CAAC,eAAe,CAAC;QAC9B,OAAOK,MAAM,CAACT,IAAI,CAAC;MACrB;IACF;IACA,OAAOV,GAAG,CAACU,IAAI,CAAC;EAClB;;EAEA;EACA,SAASS,MAAMA,CAACT,IAAI,EAAE;IACpB,IAAI7B,UAAU,CAAC6B,IAAI,CAAC,IAAI,EAAEF,IAAI,GAAG,EAAE,EAAE;MACnCV,OAAO,CAACsB,OAAO,CAACV,IAAI,CAAC;MACrB,OAAOS,MAAM;IACf;IACA,IAAI,CAAC,CAAClB,IAAI,CAACiB,SAAS,IAAIV,IAAI,GAAG,CAAC,MAAMP,IAAI,CAACW,cAAc,CAACC,MAAM,GAAGH,IAAI,KAAKT,IAAI,CAACW,cAAc,CAACC,MAAM,GAAGH,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,EAAE,CAAC,EAAE;MACpIZ,OAAO,CAACT,IAAI,CAAC,eAAe,CAAC;MAC7B,OAAO4B,QAAQ,CAACP,IAAI,CAAC;IACvB;IACA,OAAOV,GAAG,CAACU,IAAI,CAAC;EAClB;;EAEA;AACF;AACA;EACE,SAASO,QAAQA,CAACP,IAAI,EAAE;IACtBZ,OAAO,CAACgB,KAAK,CAAC,gBAAgB,CAAC;IAC/BhB,OAAO,CAACsB,OAAO,CAACV,IAAI,CAAC;IACrBZ,OAAO,CAACT,IAAI,CAAC,gBAAgB,CAAC;IAC9BY,IAAI,CAACW,cAAc,CAACC,MAAM,GAAGZ,IAAI,CAACW,cAAc,CAACC,MAAM,IAAIH,IAAI;IAC/D,OAAOZ,OAAO,CAACkB,KAAK,CAACjC,SAAS;IAC9B;IACAkB,IAAI,CAACiB,SAAS,GAAGlB,GAAG,GAAGqB,OAAO,EAAEvB,OAAO,CAACwB,OAAO,CAAC7B,iCAAiC,EAAE8B,WAAW,EAAEC,WAAW,CAAC,CAAC;EAC/G;;EAEA;EACA,SAASH,OAAOA,CAACX,IAAI,EAAE;IACrBT,IAAI,CAACW,cAAc,CAACa,gBAAgB,GAAG,IAAI;IAC3CpB,WAAW,EAAE;IACb,OAAOkB,WAAW,CAACb,IAAI,CAAC;EAC1B;;EAEA;EACA,SAASc,WAAWA,CAACd,IAAI,EAAE;IACzB,IAAI5B,aAAa,CAAC4B,IAAI,CAAC,EAAE;MACvBZ,OAAO,CAACgB,KAAK,CAAC,0BAA0B,CAAC;MACzChB,OAAO,CAACsB,OAAO,CAACV,IAAI,CAAC;MACrBZ,OAAO,CAACT,IAAI,CAAC,0BAA0B,CAAC;MACxC,OAAOkC,WAAW;IACpB;IACA,OAAOvB,GAAG,CAACU,IAAI,CAAC;EAClB;;EAEA;EACA,SAASa,WAAWA,CAACb,IAAI,EAAE;IACzBT,IAAI,CAACW,cAAc,CAACJ,IAAI,GAAGH,WAAW,GAAGJ,IAAI,CAACM,cAAc,CAACT,OAAO,CAACT,IAAI,CAAC,gBAAgB,CAAC,EAAE,IAAI,CAAC,CAACe,MAAM;IACzG,OAAOL,EAAE,CAACW,IAAI,CAAC;EACjB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAStB,wBAAwBA,CAACU,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EAClD,MAAMC,IAAI,GAAG,IAAI;EACjBA,IAAI,CAACW,cAAc,CAACc,UAAU,GAAGC,SAAS;EAC1C,OAAO7B,OAAO,CAACkB,KAAK,CAACjC,SAAS,EAAEsC,OAAO,EAAEO,QAAQ,CAAC;;EAElD;EACA,SAASP,OAAOA,CAACX,IAAI,EAAE;IACrBT,IAAI,CAACW,cAAc,CAACiB,iBAAiB,GAAG5B,IAAI,CAACW,cAAc,CAACiB,iBAAiB,IAAI5B,IAAI,CAACW,cAAc,CAACa,gBAAgB;;IAErH;IACA;IACA,OAAO7C,YAAY,CAACkB,OAAO,EAAEC,EAAE,EAAE,gBAAgB,EAAEE,IAAI,CAACW,cAAc,CAACJ,IAAI,GAAG,CAAC,CAAC,CAACE,IAAI,CAAC;EACxF;;EAEA;EACA,SAASkB,QAAQA,CAAClB,IAAI,EAAE;IACtB,IAAIT,IAAI,CAACW,cAAc,CAACiB,iBAAiB,IAAI,CAAC/C,aAAa,CAAC4B,IAAI,CAAC,EAAE;MACjET,IAAI,CAACW,cAAc,CAACiB,iBAAiB,GAAGF,SAAS;MACjD1B,IAAI,CAACW,cAAc,CAACa,gBAAgB,GAAGE,SAAS;MAChD,OAAOG,gBAAgB,CAACpB,IAAI,CAAC;IAC/B;IACAT,IAAI,CAACW,cAAc,CAACiB,iBAAiB,GAAGF,SAAS;IACjD1B,IAAI,CAACW,cAAc,CAACa,gBAAgB,GAAGE,SAAS;IAChD,OAAO7B,OAAO,CAACwB,OAAO,CAAC1B,eAAe,EAAEG,EAAE,EAAE+B,gBAAgB,CAAC,CAACpB,IAAI,CAAC;EACrE;;EAEA;EACA,SAASoB,gBAAgBA,CAACpB,IAAI,EAAE;IAC9B;IACAT,IAAI,CAACW,cAAc,CAACc,UAAU,GAAG,IAAI;IACrC;IACAzB,IAAI,CAACiB,SAAS,GAAGS,SAAS;IAC1B;;IAEA,OAAO/C,YAAY,CAACkB,OAAO,EAAEA,OAAO,CAACwB,OAAO,CAACrC,IAAI,EAAEc,EAAE,EAAEC,GAAG,CAAC,EAAE,YAAY,EAAEC,IAAI,CAAC8B,MAAM,CAACC,UAAU,CAACC,OAAO,CAACC,IAAI,CAACC,QAAQ,CAAC,cAAc,CAAC,GAAGR,SAAS,GAAG,CAAC,CAAC,CAACjB,IAAI,CAAC;EAChK;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASb,cAAcA,CAACC,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EACxC,MAAMC,IAAI,GAAG,IAAI;EACjB,OAAOrB,YAAY,CAACkB,OAAO,EAAEsC,WAAW,EAAE,gBAAgB,EAAEnC,IAAI,CAACW,cAAc,CAACJ,IAAI,GAAG,CAAC,CAAC;;EAEzF;EACA,SAAS4B,WAAWA,CAAC1B,IAAI,EAAE;IACzB,MAAMR,IAAI,GAAGD,IAAI,CAACE,MAAM,CAACF,IAAI,CAACE,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC;IAChD,OAAOF,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,CAACI,IAAI,KAAK,gBAAgB,IAAIJ,IAAI,CAAC,CAAC,CAAC,CAACK,cAAc,CAACL,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAACE,MAAM,KAAKH,IAAI,CAACW,cAAc,CAACJ,IAAI,GAAGT,EAAE,CAACW,IAAI,CAAC,GAAGV,GAAG,CAACU,IAAI,CAAC;EACtJ;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASpB,eAAeA,CAACQ,OAAO,EAAE;EAChCA,OAAO,CAACT,IAAI,CAAC,IAAI,CAACuB,cAAc,CAACN,IAAI,CAAC;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASX,gCAAgCA,CAACG,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EAC1D,MAAMC,IAAI,GAAG,IAAI;;EAEjB;;EAEA,OAAOrB,YAAY,CAACkB,OAAO,EAAEsC,WAAW,EAAE,0BAA0B,EAAEnC,IAAI,CAAC8B,MAAM,CAACC,UAAU,CAACC,OAAO,CAACC,IAAI,CAACC,QAAQ,CAAC,cAAc,CAAC,GAAGR,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC;;EAEvJ;EACA,SAASS,WAAWA,CAAC1B,IAAI,EAAE;IACzB,MAAMR,IAAI,GAAGD,IAAI,CAACE,MAAM,CAACF,IAAI,CAACE,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC;IAChD,OAAO,CAACtB,aAAa,CAAC4B,IAAI,CAAC,IAAIR,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,CAACI,IAAI,KAAK,0BAA0B,GAAGP,EAAE,CAACW,IAAI,CAAC,GAAGV,GAAG,CAACU,IAAI,CAAC;EAC3G;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}