{"ast":null,"code":"/**\n * @import {Chunk, Code, Encoding, Value} from 'micromark-util-types'\n */\n\n/**\n * @callback Preprocessor\n *   Preprocess a value.\n * @param {Value} value\n *   Value.\n * @param {Encoding | null | undefined} [encoding]\n *   Encoding when `value` is a typed array (optional).\n * @param {boolean | null | undefined} [end=false]\n *   Whether this is the last chunk (default: `false`).\n * @returns {Array<Chunk>}\n *   Chunks.\n */\n\nconst search = /[\\0\\t\\n\\r]/g;\n\n/**\n * @returns {Preprocessor}\n *   Preprocess a value.\n */\nexport function preprocess() {\n  let column = 1;\n  let buffer = '';\n  /** @type {boolean | undefined} */\n  let start = true;\n  /** @type {boolean | undefined} */\n  let atCarriageReturn;\n  return preprocessor;\n\n  /** @type {Preprocessor} */\n  // eslint-disable-next-line complexity\n  function preprocessor(value, encoding, end) {\n    /** @type {Array<Chunk>} */\n    const chunks = [];\n    /** @type {RegExpMatchArray | null} */\n    let match;\n    /** @type {number} */\n    let next;\n    /** @type {number} */\n    let startPosition;\n    /** @type {number} */\n    let endPosition;\n    /** @type {Code} */\n    let code;\n    value = buffer + (typeof value === 'string' ? value.toString() : new TextDecoder(encoding || undefined).decode(value));\n    startPosition = 0;\n    buffer = '';\n    if (start) {\n      // To do: `markdown-rs` actually parses BOMs (byte order mark).\n      if (value.charCodeAt(0) === 65279) {\n        startPosition++;\n      }\n      start = undefined;\n    }\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition;\n      match = search.exec(value);\n      endPosition = match && match.index !== undefined ? match.index : value.length;\n      code = value.charCodeAt(endPosition);\n      if (!match) {\n        buffer = value.slice(startPosition);\n        break;\n      }\n      if (code === 10 && startPosition === endPosition && atCarriageReturn) {\n        chunks.push(-3);\n        atCarriageReturn = undefined;\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(-5);\n          atCarriageReturn = undefined;\n        }\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition));\n          column += endPosition - startPosition;\n        }\n        switch (code) {\n          case 0:\n            {\n              chunks.push(65533);\n              column++;\n              break;\n            }\n          case 9:\n            {\n              next = Math.ceil(column / 4) * 4;\n              chunks.push(-2);\n              while (column++ < next) chunks.push(-1);\n              break;\n            }\n          case 10:\n            {\n              chunks.push(-4);\n              column = 1;\n              break;\n            }\n          default:\n            {\n              atCarriageReturn = true;\n              column = 1;\n            }\n        }\n      }\n      startPosition = endPosition + 1;\n    }\n    if (end) {\n      if (atCarriageReturn) chunks.push(-5);\n      if (buffer) chunks.push(buffer);\n      chunks.push(null);\n    }\n    return chunks;\n  }\n}","map":{"version":3,"names":["search","preprocess","column","buffer","start","atCarriageReturn","preprocessor","value","encoding","end","chunks","match","next","startPosition","endPosition","code","toString","TextDecoder","undefined","decode","charCodeAt","length","lastIndex","exec","index","slice","push","Math","ceil"],"sources":["/home/cameron/Desktop/AlbaSoftwareWebsite/articleswebsite/site/node_modules/micromark/lib/preprocess.js"],"sourcesContent":["/**\n * @import {Chunk, Code, Encoding, Value} from 'micromark-util-types'\n */\n\n/**\n * @callback Preprocessor\n *   Preprocess a value.\n * @param {Value} value\n *   Value.\n * @param {Encoding | null | undefined} [encoding]\n *   Encoding when `value` is a typed array (optional).\n * @param {boolean | null | undefined} [end=false]\n *   Whether this is the last chunk (default: `false`).\n * @returns {Array<Chunk>}\n *   Chunks.\n */\n\nconst search = /[\\0\\t\\n\\r]/g;\n\n/**\n * @returns {Preprocessor}\n *   Preprocess a value.\n */\nexport function preprocess() {\n  let column = 1;\n  let buffer = '';\n  /** @type {boolean | undefined} */\n  let start = true;\n  /** @type {boolean | undefined} */\n  let atCarriageReturn;\n  return preprocessor;\n\n  /** @type {Preprocessor} */\n  // eslint-disable-next-line complexity\n  function preprocessor(value, encoding, end) {\n    /** @type {Array<Chunk>} */\n    const chunks = [];\n    /** @type {RegExpMatchArray | null} */\n    let match;\n    /** @type {number} */\n    let next;\n    /** @type {number} */\n    let startPosition;\n    /** @type {number} */\n    let endPosition;\n    /** @type {Code} */\n    let code;\n    value = buffer + (typeof value === 'string' ? value.toString() : new TextDecoder(encoding || undefined).decode(value));\n    startPosition = 0;\n    buffer = '';\n    if (start) {\n      // To do: `markdown-rs` actually parses BOMs (byte order mark).\n      if (value.charCodeAt(0) === 65279) {\n        startPosition++;\n      }\n      start = undefined;\n    }\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition;\n      match = search.exec(value);\n      endPosition = match && match.index !== undefined ? match.index : value.length;\n      code = value.charCodeAt(endPosition);\n      if (!match) {\n        buffer = value.slice(startPosition);\n        break;\n      }\n      if (code === 10 && startPosition === endPosition && atCarriageReturn) {\n        chunks.push(-3);\n        atCarriageReturn = undefined;\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(-5);\n          atCarriageReturn = undefined;\n        }\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition));\n          column += endPosition - startPosition;\n        }\n        switch (code) {\n          case 0:\n            {\n              chunks.push(65533);\n              column++;\n              break;\n            }\n          case 9:\n            {\n              next = Math.ceil(column / 4) * 4;\n              chunks.push(-2);\n              while (column++ < next) chunks.push(-1);\n              break;\n            }\n          case 10:\n            {\n              chunks.push(-4);\n              column = 1;\n              break;\n            }\n          default:\n            {\n              atCarriageReturn = true;\n              column = 1;\n            }\n        }\n      }\n      startPosition = endPosition + 1;\n    }\n    if (end) {\n      if (atCarriageReturn) chunks.push(-5);\n      if (buffer) chunks.push(buffer);\n      chunks.push(null);\n    }\n    return chunks;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}